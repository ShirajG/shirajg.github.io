---
layout: post
---
        <h4><span>Inheritance and Composition</span></h4>
        <p>
          This weeks topic is going to be the distinction between inheritance and composition. I'll go over what inheritance is, why to use it, and then show you what composition is, and how it differs from inheritance.
          I'm just learning about these topics and still find it a little confusing, but I thought tackling a blog post about it would force me to do some research and really try to understand the topic.
        </p>
        <p>
          To start off, I will give a brief overview of inheritance. In Object Oriented Programming, inheritance is a way to let classes have methods in common without having to define them in each class. This lets an object "inherit" from a parent class. This can be useful in cases where an object has all the same properties and methods as another, but also has some properties unique to itself. Lets try an example.
        </p>
        <div class="code">
        <p>
          class Rectangle <br><br>
          &nbsp;&nbsp;def initialize (length, width) <br>
          &nbsp;&nbsp;&nbsp;&nbsp;@length = length <br>
          &nbsp;&nbsp;&nbsp;&nbsp;@width = width <br>
          &nbsp;&nbsp;end<br><br>
          &nbsp;&nbsp;def area<br>
          &nbsp;&nbsp;&nbsp;&nbsp;@length * @width <br>
          &nbsp;&nbsp;end<br><br>
          &nbsp;&nbsp;def perimeter<br>
          &nbsp;&nbsp;&nbsp;&nbsp;2 * (@length + @width) <br>
          &nbsp;&nbsp;end<br><br>
          end<br>
        </p>
      </div>
      <p>
        So in the above, I've created a Rectangle class that also contains methods for calculating the perimeter and area of the rectangle. Now lets go one step further and create a Square class that will <i>inherit</i> the methods of Rectangle.
      </p>
      <div class="code">
        <p>
          class Square < Rectangle<br><br>
          &nbsp;&nbsp;def initialize (length) <br>
          &nbsp;&nbsp;&nbsp;&nbsp;@length = length <br>
          &nbsp;&nbsp;&nbsp;&nbsp;@width = length <br>
          &nbsp;&nbsp;end<br><br>
          end<br>
        </p>
      </div>
      <p>
        So now we've specified that class Square inherits from class Rectangle via the '<' operator. This means that Square now has access to all of the methods that Rectangle had. You can also see that I redefined the initialization method for Square. This is one of the useful aspects of using inheritance. If you need to overwrite or modify any of the parent class's methods you're free to do so. This lets you reuse code and make only minor tweaks, rather than having to write the whole class from scratch. 
      </p>
      <p>
        There is however a catch, in Ruby, a class can only inherit from one class. This means that you can not mix and match methods from different classes via the inheritance technique. This is where composition comes in. 
      </p>
      <p>
        The thinking behind composition is similar to inheritance but differs in some significant ways. Lets see an example of how we can start using composition.  
      </p>
      <div class="code">
        <p>
          module Functions<br><br>
          &nbsp;&nbsp;def area <br>
          &nbsp;&nbsp;&nbsp;&nbsp;@length * @width <br>
          &nbsp;&nbsp;end<br><br>
          &nbsp;&nbsp;def perimeter<br>
          &nbsp;&nbsp;&nbsp;&nbsp;2 * (@length + @width)<br>
          &nbsp;&nbsp;end<br><br>
          end<br><br>
          class Rectangle<br>
          &nbsp;&nbsp;include Functions<br><br>
          &nbsp;&nbsp;def initialize (length, width) <br>
          &nbsp;&nbsp;&nbsp;&nbsp;@length = length <br>
          &nbsp;&nbsp;&nbsp;&nbsp;@width = width <br>
          &nbsp;&nbsp;end<br><br>
          end<br><br>
          class Square<br>
          &nbsp;&nbsp;include Functions<br><br>
          &nbsp;&nbsp;def initialize (length) <br>
          &nbsp;&nbsp;&nbsp;&nbsp;@length = length <br>
          &nbsp;&nbsp;&nbsp;&nbsp;@width = length <br>
          &nbsp;&nbsp;end<br><br>
          end<br>
        </p>
      </div>
      <p>
        In the above example I've create a <i>Module</i> that holds the 
        methods for area and perimeter. You can think of a Module like a container for methods. You can really store whatever you want in a Module and then access it from anywhere in your program. When you want to use what's in your Module, all you have to do is use the "include" keyword followed by the Module name. In this example, I moved all the useful methods for area and perimeter into the Functions module. This allows me to just include the Function module in Rectangle and Square without the need for inheritance.  
      </p>
      <p>
        There is also no limit to the amount of modules that can be included in a class. This allows you to have a large amount of control over what methods you can pull into the class, since you are not limited to just one Class that you can inherit from. You can think of it almost like having access to a huge library of books, and just checking out one or two books when you need them. 
      </p>
      <p>
        Composition also frees you from having to determine a strict class hierarchy ahead of time. You don't need to shoehorn one class into inheriting from another class just because you think it will need one of the methods that the other class has access to. This can lead to much more logically organized code, as well as making debugging easier, as you no longer have to hunt through a long inheritance chain to figure out what's going wrong.
      </p>
      <p>
        Composition also allows you to separate state from behavior. Notice that the methods in the module make no attempt at defining a data structure. This responsibility rests solely with the class. As long as the class defines instance variables for @width and @length, the methods in the module will work. This lets you focus on laying out classes so that they represent the object you're trying to model, and then just include the appropriate processing methods from modules, or write them specifically into the class.
      </p>
      <p>
        As our programs grow larger and more complex, having an explicit way of storing our frequently used methods for inclusion in classes later on is going to become important. Having a well organized code base will help us troubleshoot bugs more easily, and allow us to code more efficiently.
      </p>